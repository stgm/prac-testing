module Week2Solutions

where

import Week2
import Data.List

--
-- Question 1 - time spent: 1.5 hours
--

data Shape = NoTriangle | Equilateral
           | Isosceles  | Rectangular | Other deriving (Eq,Show)

triangle :: Integer -> Integer -> Integer -> Shape
triangle x y z
    | let [a,b,c] = sort [x,y,z] in a + b <= c                 = NoTriangle
    | x == y && y == z                                         = Equilateral
    | x^2 + y^2 == z^2 || x^2 + z^2 == y^2 || z^2 + y^2 == x^2 = Rectangular
    | x == y || y == z || z == x                               = Isosceles
    | otherwise                                                = Other

{--
    NoTriangle definition

    VVZ:
        incorrect, counter-example: triangle 1 2 1000

    VVZ':
        still not fixed

    GROUP:
        OK we got the formal definition that any two sides should be longer than 
        the other (in this case we take the shortest two)
-}

{--
    Rectangular definition 

    VVZ:
        correct, but slightly inefficient, you could've written another 
        function that works with sorted triples

    VVZ':
        this one is okay, it was a warning/advice anyway
-}

--
-- Question 1 check cases
--

checkTriangle =
            checkNoTriangle &&
            checkEquilateral &&
            checkRectangular &&
            checkIsosceles &&
            checkOther

{--
    VVZ:
        kinda correct, but 40 lines of code for something that could have 
        been generated by a Haskell oneliner is somewhat inefficient
-}

checkNoTriangle =
    triangle 0 0 0    == NoTriangle &&
    triangle 0 0 1    == NoTriangle &&
    triangle 0 1 0    == NoTriangle &&
    triangle 1 0 0    == NoTriangle &&
    triangle 1 1 0    == NoTriangle &&
    triangle 1 0 1    == NoTriangle &&
    triangle 0 1 1    == NoTriangle &&
    triangle (-1) 1 1 == NoTriangle &&
    triangle 1 (-1) 1 == NoTriangle &&
    triangle 1 1 (-1) == NoTriangle &&
    triangle 1 1 1    /= NoTriangle &&
    triangle 1 2 1000 == NoTriangle

checkEquilateral =
    triangle 1 1 0 /= Equilateral &&
    triangle 0 0 0 /= Equilateral &&
    triangle 1 2 3 /= Equilateral &&
    triangle 1 1 2 /= Equilateral &&
    triangle 1 2 1 /= Equilateral &&
    triangle 2 1 1 /= Equilateral &&
    triangle 1 1 1 == Equilateral &&
    triangle 2 2 2 == Equilateral &&
    triangle 3 3 3 == Equilateral

checkRectangular =
    triangle 0 0 0 /= Rectangular &&
    triangle 1 1 2 /= Rectangular &&
    triangle 3 4 5 == Rectangular &&
    triangle 4 3 5 == Rectangular &&
    triangle 5 4 3 == Rectangular &&
    triangle 5 12 13 == Rectangular

checkIsosceles =
    triangle 1 1 1 /= Isosceles &&
    triangle 2 2 2 /= Isosceles &&
    triangle 1 1 2 == Isosceles &&
    triangle 1 2 1 == Isosceles &&
    triangle 2 1 1 == Isosceles

{-- 
    VVZ: Y U NO have positive tests?
    VVZ: btw, this is where generation could have helped you enormously: 
         within triangles with sides between 1 and 5 there only two
    VVZ: which are correct but belong to "other"
-}

checkOther =
    triangle 0 0 0 /= Other &&
    triangle 1 1 1 /= Other &&
    triangle 3 4 5 /= Other &&
    triangle 1 1 2 /= Other

--
-- Question 2 - Time spent: 2 hours
--

-- VVZ: correct, but a shorter notation would be "contradiction = not . satisfiable"

contradiction :: Form -> Bool
contradiction f = not (satisfiable f)

tautology :: Form -> Bool
tautology f = all (\ v -> eval v f) (allVals f)

entails :: Form -> Form -> Bool
entails f1 f2 = tautology (Impl f1 f2)

equiv :: Form -> Form -> Bool
equiv f1 f2 = tautology (Equiv f1 f2)

--
-- Question 2 check cases
--

checkQuestion2 = 
            checkContradiction && 
            checkTautology && 
            checkEntails && 
            checkEquiv 

-- these formulas are proved during the workshop
form_Contradiction = Cnj [p, Neg p]
form_Tautology = Dsj [p, Neg p]
form1_Implication = Cnj [p, Neg p]
form2_Implication = Dsj [p, Neg p]
form1_Equivalence = Neg (Cnj [Neg p,Neg q])
form2_Equivalence = Dsj [p, q]

checkContradiction =
    contradiction form_Contradiction &&
    not(contradiction form_Tautology) &&
    not(contradiction form1) &&
    not(contradiction form2) &&
    not(contradiction form3)

checkTautology =
    tautology form_Tautology &&
    not(tautology form_Contradiction) 

checkEntails =
    not(entails form_Tautology form_Contradiction) &&
    entails form1_Implication form2_Implication

checkEquiv =
    equiv form1_Equivalence form2_Equivalence &&
    not(equiv form1_Equivalence form_Contradiction) &&
            -- equivalence theorem formulas (see Theorem 2.10, Haskell Road to Logic, p.46)
            equiv (p) (Neg (Neg p)) && -- 1
            equiv (p) (Cnj [p, p]) && -- 2a
            equiv (p) (Dsj [p, p]) && -- 2b
            equiv (Impl p q) (Dsj [Neg p, q]) && -- 3a
            equiv (Neg (Impl p q)) (Cnj [p, Neg q]) && -- 3b
            equiv (Impl (Neg p) (Neg q)) (Impl q p) && -- 4a
            equiv (Impl p (Neg q)) (Impl q (Neg p)) && -- 4b
            equiv (Impl (Neg p) q) (Impl (Neg q) p) && -- 4c
            equiv (Equiv p q) (Cnj [(Impl p q), (Impl q p)]) && -- 5a
            equiv (Equiv p q) (Dsj [(Cnj [p, q]), (Cnj [Neg p, Neg q])]) && -- 5b
            equiv (Cnj [p, q]) (Cnj [q, p]) && -- 6a
            equiv (Dsj [p, q]) (Dsj [q, p]) && -- 6b
            equiv (Neg (Cnj [p, q])) (Dsj [Neg p, Neg q]) && -- 7a
            equiv (Neg (Dsj [p, q])) (Cnj [Neg p, Neg q]) && -- 7b
            equiv (Cnj [p, Cnj [q, r]]) (Cnj [Cnj [p, q], r]) && -- 8a
            equiv (Dsj [p, Dsj [q, r]]) (Dsj [Dsj [p, q], r]) && -- 8b
            equiv (Cnj [p, Dsj [q, r]]) (Dsj [Cnj [p, q], Cnj [p, r]]) && -- 9a
            equiv (Dsj [p, Cnj [q, r]]) (Cnj [Dsj [p, q], Dsj [p, r]]) -- 9b

--
-- Question 3
--

{--
    VVZ:
        incorrect, missing lots of cases. the simplest counterexample is from 
        the first from above: (Neg (Neg p))

    GROUP:
        according to the precondition the input must be arrow-free and in nnf,
        so no (Neg (Neg p)) can not occur anymore for the input and hence we
        donâ€™t have to check it here anymore (same goes for De Morgan law which
        is already handled in nnf function)
-}

{--
    VVZ:
        treating of disjunction is incorrect: the Haskell implementation 
        allows for three and more elements in a clause

    GROUP:
        Fixed this by adding the Dsj multi-element line

    VVZ:
        looks to me like it should be
            cnf (Dsj (f:fs)) = dist (cnf f) (cnf (Dsj fs))
-}

-- precondition: input is arrow-free and in nnf
cnf:: Form -> Form 
cnf (Prop x) = Prop x
cnf (Cnj fs) = Cnj (map cnf fs)
cnf (Dsj [f1,f2]) = dist f1 f2
cnf (Dsj (f:fs))  = dist f (cnf (Dsj fs))
cnf f             = f

{-- 
    VVZ:
        incorrect, works correctly only on two-element lists, which is not
        reflected by the type (hence, the spec and the program don't agree)
        also, a binary version could have been simplified (you don't need to 
        use map if you know there are only two elements)

    GROUP:
        Fixed by making dist function accept two Form parameters

    VVZ':
        no, it is absolutely not fixed. Showing you the correct implementation 
        of dist:

            dist :: Form -> Form -> Form
            dist (Cnj []) _ = Cnj []
            dist (Cnj [f1]) f2 = dist f1 f2
            dist (Cnj (f1:fs)) f2 = Cnj [dist f1 f2, dist (Cnj fs) f2]
            dist _ (Cnj []) = Cnj []
            dist f1 (Cnj [f2]) = dist f1 f2
            dist f1 (Cnj (f2:fs)) = Cnj [dist f1 f2, dist f1 (Cnj fs)]
            dist f1 f2 = Dsj [f1,f2]
-}

-- precondition: input is in cnf
dist :: Form -> Form -> Form
dist (Cnj [f1,f2]) f3 = Cnj [dist f1 f3, dist f2 f3]
dist f1 (Cnj [f2,f3]) = Cnj [dist f1 f2, dist f1 f3]
dist f1 f2            = Dsj [f1,f2]

{-- 
    VVZ: incorrect, counterexample: cnf (Cnj [Cnj [p,q], q])

    GROUP: 
        Is it not correct that the result is the same as the form for the
        counterexample you give here? This example form is already in CNF,
        isn't it?
        Or do you mean that the nested conjunctions need to be flattened out?
        So the cnf results in Cnj [p,q,q] or Cnj [p,q]?? Because the grammar of
        CNF does not - according to us - indicate this. 

    VVZ':
        (1) the grammar starts as C = D | D and C. Even if you assign Haskell 
            semantics directly to this grammar, it does mean that the leftmost 
            operand is a disjunction. In your implementation you do NOT check
            that.
        (2) during the workshop, we had a formal definition of CNF as
            "conjunction of disjunctions", and did an exercise about defining disjunctive normal form similarly. 
        (3) the Haskell type definition has no need for nested conjunctions.
            Think about defining any kind of algorithm that operates on nested
            con/disjunctions, and how much trouble one would need to go through to define it. Normalisations exist to make life of programmers easier, so what would be the point of normalising everything nicely yet allowing something that nullifies the effort?
        (4) in general it is a good idea to discuss these things directly 
            (Monday lab, Monday lecture, Monday workshop, Tuesday lab, FAQ,
            email) instead of trying to argue in the comments, by pushing
            misinterpretation into next weeks.
-}

{--
    VVZ:
        The grammar of CNF is slightly different than the data type definition 
        in Haskell: it needs to allow nested conjunctions since the conjunction 
        there is binary. In the implementation, we go for the list-based 
        conjunction/disjunction, which is easier to operate on a computer.
-}

-- function to convert any form to cnf
fromAnyFormToCnf :: Form -> Form
fromAnyFormToCnf = cnf . nnf . arrowfree

--
-- Question 3 check cases
--

{-- 
    VVZ:
        incorrect! only tests if the transformation to CNF preserves the
        equivalence; never tests if the result actually conforms to the 
        definition of CNF (and it does not for many, try to run 
            "cnf form1_Equivalence")

    GROUP:
        Almost fixed.. functionsBoundWithCnj function needs to be still 
        implemented to make the check complete.

    VVZ':
        and where is it?

    GROUP:
        in the original comment, you were using the function `cnf` in the
        example. this is, however, not the complete cnf converter. to use
        the complete converter, use `fromAnyFormToCnf`. We understand that
        is not directly relevant to the problem in checkCnf though, which
        we fixed below by using the definition of Cnf directly.
-}

checkCnfConvertionSampleForms = map checkCnf [form_Tautology, form1_Implication, form1_Equivalence, form_Contradiction] 

checkCnf :: Form -> Bool
checkCnf f = equiv f f' &&
             checkConformityToCnf f'
             where f' = fromAnyFormToCnf f

-- we need to check whether nnf and arrowFree were applied correctly, 
-- also whether functions are bound with conjunctions together, so disjunctions should be pushed to the inside functions 
checkConformityToCnf :: Form -> Bool
checkConformityToCnf (Cnj fs)       = and $ map isFlatDsj fs
checkConformityToCnf (Dsj fs)       = and $ map isFlatDsj fs
checkConformityToCnf (Prop x)       = True
checkConformityToCnf (Neg (Prop x)) = True
checkConformityToCnf other          = False

isFlatDsj :: Form -> Bool
isFlatDsj (Prop x)       = True
isFlatDsj (Neg (Prop x)) = True
isFlatDsj (Dsj fs)       = and $ map isFlatDsj fs
isFlatDsj other          = False
